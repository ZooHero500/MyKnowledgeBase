import{_ as i,c as a,a0 as t,o as e}from"./chunks/framework.p2VkXzrt.js";const n="/assets/image.D11fQrde.png",E=JSON.parse('{"title":"React 生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"React/lifecycle.md","filePath":"React/lifecycle.md"}'),l={name:"React/lifecycle.md"};function p(h,s,o,k,r,d){return e(),a("div",null,s[0]||(s[0]=[t('<p>以下是按照苹果的标准格式化的 Markdown 内容：</p><h1 id="react-生命周期" tabindex="-1">React 生命周期 <a class="header-anchor" href="#react-生命周期" aria-label="Permalink to &quot;React 生命周期&quot;">​</a></h1><p><img src="'+n+`" alt="React 生命周期图"></p><p>React 组件生命周期分为三个主要阶段：挂载、更新和卸载。对于类组件，React 提供了一些方法，允许我们在组件生命周期的不同阶段执行代码。以下是一些常见的操作方法（注意，这些方法是类组件的生命周期方法，函数组件的概念有所不同）。</p><p>在 React 的 class component 中，生命周期分为三个主要阶段：mounting（挂载）、updating（更新）和 unmounting（卸载）。每个阶段都有特定的生命周期方法，触发的时机如下：</p><h2 id="_1-mounting-挂载" tabindex="-1">1. Mounting（挂载） <a class="header-anchor" href="#_1-mounting-挂载" aria-label="Permalink to &quot;1. Mounting（挂载）&quot;">​</a></h2><p>这个阶段是组件被创建并插入到 DOM 中的过程。相关的生命周期方法包括：</p><ul><li><code>constructor(props)</code>：在组件实例化时调用，初始化状态和绑定方法。</li><li><code>static getDerivedStateFromProps(nextProps, prevState)</code>：在渲染之前调用，可以返回一个对象来更新状态，或返回 null 表示不更新。</li><li><code>render()</code>：必须实现的方法，返回要渲染的 JSX。</li><li><code>componentDidMount()</code>：组件挂载后调用，适合进行数据获取、添加事件监听等操作。</li></ul><h2 id="_2-updating-更新" tabindex="-1">2. Updating（更新） <a class="header-anchor" href="#_2-updating-更新" aria-label="Permalink to &quot;2. Updating（更新）&quot;">​</a></h2><p>这个阶段是组件的状态或属性发生变化时的过程。相关的生命周期方法包括：</p><ul><li><code>static getDerivedStateFromProps(nextProps, prevState)</code>：在更新时调用，功能与挂载阶段相同。</li><li><code>shouldComponentUpdate(nextProps, nextState)</code>：在渲染前调用，用于控制组件是否需要更新，返回 true 或 false。</li><li><code>render()</code>：更新时重新渲染组件。</li><li><code>componentDidUpdate(prevProps, prevState)</code>：组件更新后调用，可以用于处理更新后的 DOM 操作或网络请求。</li></ul><h2 id="_3-unmounting-卸载" tabindex="-1">3. Unmounting（卸载） <a class="header-anchor" href="#_3-unmounting-卸载" aria-label="Permalink to &quot;3. Unmounting（卸载）&quot;">​</a></h2><p>这个阶段是组件从 DOM 中移除的过程。相关的生命周期方法包括：</p><ul><li><code>componentWillUnmount()</code>：在组件卸载之前调用，适合进行清理操作，如移除事件监听、取消网络请求等。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ol><li>Mounting：组件创建并插入 DOM。 <ul><li>方法：constructor → getDerivedStateFromProps → render → componentDidMount</li></ul></li><li>Updating：组件状态或属性更新。 <ul><li>方法：getDerivedStateFromProps → shouldComponentUpdate → render → componentDidUpdate</li></ul></li><li>Unmounting：组件从 DOM 中移除。 <ul><li>方法：componentWillUnmount</li></ul></li></ol><hr><h1 id="react-hooks-与类组件生命周期的对应关系" tabindex="-1">React Hooks 与类组件生命周期的对应关系 <a class="header-anchor" href="#react-hooks-与类组件生命周期的对应关系" aria-label="Permalink to &quot;React Hooks 与类组件生命周期的对应关系&quot;">​</a></h1><h2 id="_1-mounting-挂载-阶段" tabindex="-1">1. Mounting（挂载）阶段 <a class="header-anchor" href="#_1-mounting-挂载-阶段" aria-label="Permalink to &quot;1. Mounting（挂载）阶段&quot;">​</a></h2><h3 id="constructor-props" tabindex="-1">constructor(props) <a class="header-anchor" href="#constructor-props" aria-label="Permalink to &quot;constructor(props)&quot;">​</a></h3><ul><li>Hook 等价：<code>useState</code> 和函数组件体</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initialState);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里可以进行一些初始化操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="static-getderivedstatefromprops-props-state" tabindex="-1">static getDerivedStateFromProps(props, state) <a class="header-anchor" href="#static-getderivedstatefromprops-props-state" aria-label="Permalink to &quot;static getDerivedStateFromProps(props, state)&quot;">​</a></h3><ul><li>Hook 等价：<code>useState</code> 结合 <code>useEffect</code></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initialState);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 需要更新状态的条件 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 新的状态 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 相关的 props */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="render" tabindex="-1">render() <a class="header-anchor" href="#render" aria-label="Permalink to &quot;render()&quot;">​</a></h3><ul><li>Hook 等价：函数组件的返回值</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;组件内容&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="componentdidmount" tabindex="-1">componentDidMount() <a class="header-anchor" href="#componentdidmount" aria-label="Permalink to &quot;componentDidMount()&quot;">​</a></h3><ul><li>Hook 等价：<code>useEffect</code> with empty dependency array</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 组件挂载后执行的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre></div><h2 id="_2-updating-更新-阶段" tabindex="-1">2. Updating（更新）阶段 <a class="header-anchor" href="#_2-updating-更新-阶段" aria-label="Permalink to &quot;2. Updating（更新）阶段&quot;">​</a></h2><h3 id="shouldcomponentupdate-nextprops-nextstate" tabindex="-1">shouldComponentUpdate(nextProps, nextState) <a class="header-anchor" href="#shouldcomponentupdate-nextprops-nextstate" aria-label="Permalink to &quot;shouldComponentUpdate(nextProps, nextState)&quot;">​</a></h3><ul><li>Hook 等价：<code>React.memo</code> 和 <code>useMemo</code></li></ul><p><code>React.memo</code> 是一个高阶组件，它可以将一个函数组件转换为一个记忆组件。记忆组件会对传入的 props 进行浅比较，如果 props 没有变化，则不会重新渲染组件。这样可以避免不必要的重新渲染，提高性能。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 组件逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><code>useMemo</code> 是一个 Hook，它可以用于记忆一个值。它接收一个函数和一个依赖项数组作为参数。只有当依赖项数组中的值发生变化时，函数才会重新执行，并返回新的值。这样可以避免在每次渲染时重新计算这个值，提高性能。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> memoizedValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computeExpensiveValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b), [a, b]);</span></span></code></pre></div><h3 id="componentdidupdate-prevprops-prevstate" tabindex="-1">componentDidUpdate(prevProps, prevState) <a class="header-anchor" href="#componentdidupdate-prevprops-prevstate" aria-label="Permalink to &quot;componentDidUpdate(prevProps, prevState)&quot;">​</a></h3><ul><li>Hook 等价：<code>useEffect</code> with dependencies</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在组件更新后执行的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 相关的 state 或 props */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><h2 id="_3-unmounting-卸载-阶段" tabindex="-1">3. Unmounting（卸载）阶段 <a class="header-anchor" href="#_3-unmounting-卸载-阶段" aria-label="Permalink to &quot;3. Unmounting（卸载）阶段&quot;">​</a></h2><h3 id="componentwillunmount" tabindex="-1">componentWillUnmount() <a class="header-anchor" href="#componentwillunmount" aria-label="Permalink to &quot;componentWillUnmount()&quot;">​</a></h3><ul><li>Hook 等价：<code>useEffect</code> 的清理函数</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 组件挂载后的操作</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 组件卸载前的清理操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre></div><h2 id="其他常用的-hooks" tabindex="-1">其他常用的 Hooks <a class="header-anchor" href="#其他常用的-hooks" aria-label="Permalink to &quot;其他常用的 Hooks&quot;">​</a></h2><ol><li><code>useContext</code>: 用于访问 React 的 Context</li><li><code>useReducer</code>: 用于管理复杂的组件状态</li><li><code>useCallback</code>: 用于优化性能，避免不必要的渲染</li><li><code>useRef</code>: 用于保存可变值，不会触发重新渲染</li></ol><h2 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>虽然 Hooks 不能完全一一对应类组件的生命周期方法，但它们提供了更灵活和可组合的方式来管理组件的副作用和状态。使用 Hooks，我们可以根据逻辑相关性组织代码，而不是根据生命周期方法强制拆分。</p><p>这个对照表展示了如何使用 Hooks 来实现与类组件生命周期方法相似的功能。需要注意的是，Hooks 的设计理念与类组件有所不同，它更注重逻辑的组合而非生命周期的分离。</p>`,50)]))}const g=i(l,[["render",p]]);export{E as __pageData,g as default};

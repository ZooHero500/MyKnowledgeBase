import{_ as l,c as a,a0 as e,o as t}from"./chunks/framework.p2VkXzrt.js";const s=JSON.parse('{"title":"TypeScript 手册","description":"","frontmatter":{},"headers":[],"relativePath":"TypeScript/index.md","filePath":"TypeScript/index.md"}'),r={name:"TypeScript/index.md"};function o(h,i,c,n,u,d){return t(),a("div",null,i[0]||(i[0]=[e('<h1 id="typescript-手册" tabindex="-1">TypeScript 手册 <a class="header-anchor" href="#typescript-手册" aria-label="Permalink to &quot;TypeScript 手册&quot;">​</a></h1><blockquote><p>写在前面：我学习技术的方法是边学边做，用到什么就学什么，做完某个阶段之后，再总结和沉淀自己在过程中学到的知识。 总结而言就是：做 -&gt; 总结沉淀 -&gt; 做 -&gt; 输出</p></blockquote><h3 id="_1-基础" tabindex="-1">1. 基础 <a class="header-anchor" href="#_1-基础" aria-label="Permalink to &quot;1. 基础&quot;">​</a></h3><ul><li>简介</li><li>安装和配置</li><li>基本类型</li><li>变量声明</li><li>类型推断和类型断言</li></ul><h3 id="_2-函数" tabindex="-1">2. 函数 <a class="header-anchor" href="#_2-函数" aria-label="Permalink to &quot;2. 函数&quot;">​</a></h3><ul><li>函数类型</li><li>可选参数和默认参数</li><li>剩余参数</li><li>函数重载</li></ul><h3 id="_3-接口" tabindex="-1">3. 接口 <a class="header-anchor" href="#_3-接口" aria-label="Permalink to &quot;3. 接口&quot;">​</a></h3><ul><li>接口的定义和使用</li><li>可选属性和只读属性</li><li>函数类型接口</li><li>类类型接口</li><li>继承接口</li></ul><h3 id="_4-类" tabindex="-1">4. 类 <a class="header-anchor" href="#_4-类" aria-label="Permalink to &quot;4. 类&quot;">​</a></h3><ul><li>类的定义和实例化</li><li>继承</li><li>公共、私有和受保护的修饰符</li><li>抽象类</li><li>类与接口</li></ul><h3 id="_5-泛型" tabindex="-1">5. 泛型 <a class="header-anchor" href="#_5-泛型" aria-label="Permalink to &quot;5. 泛型&quot;">​</a></h3><ul><li>泛型函数</li><li>泛型接口</li><li>泛型类</li><li>泛型约束</li></ul><h3 id="_6-高级类型" tabindex="-1">6. 高级类型 <a class="header-anchor" href="#_6-高级类型" aria-label="Permalink to &quot;6. 高级类型&quot;">​</a></h3><ul><li>联合类型</li><li>交叉类型</li><li>类型别名</li><li>字面量类型</li><li>可辨识联合</li><li>索引类型和映射类型</li></ul><h3 id="_7-模块和命名空间" tabindex="-1">7. 模块和命名空间 <a class="header-anchor" href="#_7-模块和命名空间" aria-label="Permalink to &quot;7. 模块和命名空间&quot;">​</a></h3><ul><li>模块的导入和导出</li><li>命名空间的使用</li><li>模块解析策略</li></ul><h3 id="_8-装饰器" tabindex="-1">8. 装饰器 <a class="header-anchor" href="#_8-装饰器" aria-label="Permalink to &quot;8. 装饰器&quot;">​</a></h3><ul><li>类装饰器</li><li>方法装饰器</li><li>属性装饰器</li><li>参数装饰器</li></ul><h3 id="_9-typescript-与-javascript-的互操作性" tabindex="-1">9. TypeScript 与 JavaScript 的互操作性 <a class="header-anchor" href="#_9-typescript-与-javascript-的互操作性" aria-label="Permalink to &quot;9. TypeScript 与 JavaScript 的互操作性&quot;">​</a></h3><ul><li>声明文件（.d.ts）</li><li>使用第三方 JavaScript 库</li></ul><h3 id="_10-高级主题" tabindex="-1">10. 高级主题 <a class="header-anchor" href="#_10-高级主题" aria-label="Permalink to &quot;10. 高级主题&quot;">​</a></h3><ul><li>条件类型</li><li>类型推断和类型兼容性</li><li>协变和逆变</li><li>符号（Symbols）和迭代器（Iterators）</li></ul><h3 id="_11-typescript-最佳实践和设计模式" tabindex="-1">11. TypeScript 最佳实践和设计模式 <a class="header-anchor" href="#_11-typescript-最佳实践和设计模式" aria-label="Permalink to &quot;11. TypeScript 最佳实践和设计模式&quot;">​</a></h3><ul><li>代码组织和结构</li><li>常见设计模式在 TypeScript 中的实现</li></ul>',24)]))}const _=l(r,[["render",o]]);export{s as __pageData,_ as default};
